[TOC]

# 数组的概述

- 数组本身是==引用数据类型==，而数组中的元素可以是==任何数据类型==，包括基本数据类型和引用数据类型

- 创建数组对象会在内存中开辟一整块==连续的空间==，而数组名中引用的是 这块连续空间的首地址

- 数组的==长度一旦确定，就不能修改==

- 我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快

# 一维数组的使用

## 一维数组的声明方式

==type var[] 或 type[] var==

Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如: int a[5];

## 初始化

* 动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行

  ```java
  int[] arr = new int[3]; 
  arr[0] = 3;
  arr[1] = 9;
  arr[2] = 8;
  ```

* 静态初始化：在定义数组的同时就为数组元素分配空间并赋值

  ```java
  int arr[] = new int[]{ 3, 9, 8}; 
  //或
  int[] arr = {3,9,8};
  ```

  

## 数组元素的默认初始化值

| 数组元素类型 | 元素默认初始值              |
| ------------ | --------------------------- |
| byte         | 0                           |
| short        | 0                           |
| int          | 0                           |
| long         | 0L                          |
| float        | 0.0F                        |
| double       | 0.0                         |
| char         | 0 或写为:’\u0000’(表现为空) |
| boolean      | false                       |
| 引用类型     | null                        |

# 多维数组

* Java 语言里提供了支持多维数组的语法
* 对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。其实，==从数组底层的运行机制来看，其实没有多维数组==

|                                                              |
| ------------------------------------------------------------ |
| 格式1(==动态初始化==)：int[][] arr = new int\[3][2];         |
| 定义了名称为arr的二维数组<br /> 二维数组中有3个一维数组<br /> 每一个一维数组中有2个元素<br /> 一维数组的名称分别为arr[0], arr[1], arr[2]<br /> 给第一个一维数组1脚标位赋值为78写法是:arr\[0][1] = 78; |
| 格式2(==动态初始化==)：int[][] arr = new int\[3][];          |
| 二维数组中有3个一维数组。<br />每个一维数组都是默认初始化值null (注意:区别于格式1) <br />可以对这个三个一维数组分别进行初始化arr[0] = new int[3]; arr[1] = new int[1]; arr[2] = new int[2];<br />==注：int \[][]arr = new int\[][3]; //非法== |
| 格式3(==静态初始化==)：int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}}; |
| 定义一个名称为arr的二维数组，二维数组中有三个一维数组<br />每一个一维数组中具体元素也都已初始化<br />第一个一维数组 arr[0] = {3,8,2}; <br />第二个一维数组 arr[1] = {2,7};<br />第三个一维数组 arr[2] = {9,0,1,6};<br />第三个一维数组的长度表示方式:arr[2].length; |

* ==注意特殊写法情况：int[] x,y[]; x是一维数组，y是二维数组==
*  Java中多维数组不必都是规则矩阵形式

# Arrays工具类

| 1    | boolean equals(int[] a,int[] b)   | 判断两个数组是否相等。                 |
| ---- | --------------------------------- | -------------------------------------- |
| 2    | String toString(int[] a)          | 输出数组信息。                         |
| 3    | void fill(int[] a,int val)        | 将指定值填充到数组之中。               |
| 4    | void sort(int[] a)                | 对数组进行排序。                       |
| 5    | int binarySearch(int[] a,int key) | 对排序后的数组进行二分法检索指定的值。 |

```java
import java.util.Arrays; 
public class SortTest {
  public static void main(String[] args) {
    int [] numbers = {5,900,1,5,77,30,64,700}; 
    Arrays.sort(numbers);
    for(int i = 0; i < numbers.length; i++){
      System.out.println(numbers[i]);
    } 
  }
}
```

# 数组涉及的排序算法

## 衡量排序算法的优劣

* ==时间复杂度==：分析关键字的比较次数和记录的移动次数

* ==空间复杂度==：分析排序算法中需要多少辅助内存

* ==稳定性==：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的

## 排序算法分类

* ==内部排序==

  整个排序过程不需要借助于外部存储器(如磁盘等)，所有排序操作都在内存中完成

* ==外部排序==

  参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器(如磁盘)。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成

## 十大内部排序算法

- 选择排序：直接选择排序、堆排序
- 交换排序：冒泡排序、快速排序
- 插入排序：直接插入排序、折半插入排序、Shell排序
- 归并排序
- 桶式排序
- 基数排序

## 算法的5大特征

| 输入(Input)                   | 有0个或多个输入数据，这些输入必须有清楚的描述和定义          |
| ----------------------------- | ------------------------------------------------------------ |
| 输出(Output)                  | 至少有1个或多个输出结果，不可以没有输出结果                  |
| 有穷性(有限性，Finiteness)    | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 |
| 确定性(明确性，Definiteness)  | 算法中的每一步都有确定的含义，不会出现二义性                 |
| 可行性(有效性，Effectiveness) | 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案   |

说明：满足确定性的算法也称为：确定性算法。现在人们也关注更广泛的概念，例如考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时被称为过程(procedure)

## 冒泡排序

* 介绍

  冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来

* 排序思想

  1. 比较相邻的元素。如果第一个比第二个大(升序)，就交换他们两个
  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数
  3. 针对所有的元素重复以上的步骤，除了最后一个
  4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止

```java
    public static void main(String[] args) {
        int[] data = {9, -16, 21, 23, -30, -49, 21, 30, 30};

        for (int i = 0; i < data.length - 1; i++) {
            for (int j = 0; j < data.length - 1 - i; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = temp;
                }
            }
        }

        System.out.println(Arrays.toString(data));//[-49, -30, -16, 9, 21, 21, 23, 30, 30]
    }
```

## 快速排序

* 介绍

  快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性

  快速排序(Quick Sort)由图灵奖获得者Tony Hoare发明，被列为==20世纪十大算法之一==，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))

* 排序思想

  1. 从数列中挑出一个元素，称为"基准"(pivot)
  2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区(partition)操作
  3. 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序
  4. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代 (iteration)中，它至少会把一个元素摆到它最后的位置去

```java
    private static void swap(int[] data, int i, int j) {
        int temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }

    private static void subSort(int[] data, int start, int end) {
        if (start < end) {
            int base = data[start];
            int low = start;
            int high = end + 1;
            while (true) {
                while (low < end && data[++low] - base <= 0)
                    ;
                while (high > start && data[--high] - base >= 0)
                    ;
                if (low < high) {
                    swap(data, low, high);
                } else {
                    break;
                }
            }
            swap(data, start, high);

            subSort(data, start, high - 1);//递归调用
            subSort(data, high + 1, end);
        }
    }

    public static void quickSort(int[] data) {
        subSort(data, 0, data.length - 1);
    }


    public static void main(String[] args) {
        int[] data = {9, -16, 30, 23, -30, -49, 25, 21, 30};
        quickSort(data);
        System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
      	//[-49, -30, -16, 9, 21, 23, 25, 30, 30]
    }
```

## 排序算法性能对比

| 排序方法 | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度    | 确定性 |
| -------- | ------------------ | ------------------ | ------------------ | ------------- | ------ |
| 插入排序 | *O*(n^2^)          | *O*(n^2^)          | *O*(n)             | *O*(1)        | 稳定   |
| 希尔排序 | *O*(n^1.3^)        | *O*(n^2^)          | *O*(n)             | *O*(1)        | 不稳定 |
| 选择排序 | *O*(n^2^)          | *O*(n^2^)          | *O*(n^2^)          | *O*(1)        | 不稳定 |
| 堆排序   | *O*(nlog~2~n)      | *O*(nlog~2~n)      | *O*(nlog~2~n)      | *O*(1)        | 不稳定 |
| 冒泡排序 | *O*(n^2^)          | *O*(n^2^)          | *O*(n)             | *O*(1)        | 稳定   |
| 快速排序 | *O*(nlog~2~n)      | *O*(n^2^)          | *O*(nlog~2~n)      | *O*(nlog~2~n) | 不稳定 |
| 归并排序 | *O*(nlog~2~n)      | *O*(nlog~2~n)      | *O*(nlog~2~n)      | *O*(n)        | 稳定   |
| 计数排序 | *O*(n+k)           | *O*(n+k)           | *O*(n+k)           | *O*(n+k)      | 稳定   |
| 桶排序   | *O*(n+k)           | *O*(n^2^)          | *O*(n)             | *O*(n+k)      | 稳定   |
| 基数排序 | *O*(n*k)           | *O*(n*k)           | *O*(n*k)           | *O*(n+k)      | 稳定   |

## 各种内部排序方法性能比较

1. ==从平均时间而言==：==快速排序最佳==。但在最坏情况下时间性能不如堆排序和归并排序
2. ==从算法简单性看==：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序
3. ==从稳定性看==：直接插入排序、冒泡排序和归并排序时稳定的;而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序
4. ==从待排序的记录数n的大小看==，n较小时，宜采用简单排序;而n较大时宜采用改进排序

## 排序算法的选择

1. 若n较小(如n≤50)，可采用==直接插入==或==直接选择排序==。 当记录规模较小时，直接插入排序较好;否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜
2. 若文件初始状态基本有序(指正序)，则应选用==直接插入、冒泡或随机的快速排序==为宜
3. 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：==快速排序、堆排序或归并排序==

## 排序动画

### （简单）选择排序

![adada](images/adada.gif)

### （直接）插入排序

![](images/20191008143253.gif)



### 堆排序

![eaea](images/eaea.gif)

### 归并排序

![dada](images/dada.gif)

### 基数排序

![dadadaf](images/dadadaf.gif)

### 计数排序

![dadad](images/dadad.gif)

### 快速排序

![csdawe](images/csdawe.gif)

### 冒泡排序

![davax](images/davax.gif)

### 桶排序

![](images/20191008145723.png)

### 希尔排序

![dadscacxz](images/dadscacxz.gif)



